---
title: Размышления о типах и mypy
date: 2025-03-04T16:42:12+03:00
tags:
  - python
  - mypy
  - types
---
Аннотации типов и анализатор `mypy` уже довольно давно представлены в Python. Дальше в тексте размышления на эту тему от разработчика - питониста.
<!--more-->
Если коротко и в идеальном мире, то проектируя типы в приложении заранее мы страхуем себя от будущих рисков и снижаем когнитивную сложность для дальнейшего поддержания кода. На практике и при недостаточных данных это часто может увеличивать срок разработки и увеличивать согласование.  

Давайте немного на примерах, пусть и синтетических, где это может быть полезно:
#### Задача
У нас есть некая система работающая с деньгами и например активами. В ней присутствует несколько валют, пусть это будут рубли, евро и доллары. Стоимость активов может быть в разных валютах а пользователи хотят иметь возможность видеть баланс в одной.

#### Может быть хватит базы?  `int`\\ `float` \\ `Decimal`
Стандартные типы на первый взгляд уже вполне подходят для операций. В них уже реализованы все арифметические операции.

Но если начать делать первые шаги, то открывается куча проблем:
 - `float` не обладает нужной точность, но мы совсем немного запаримся и  можем импортировать Decimal. Но тут может отпасть код, если мы где-то использовали josn.dumps() в общем чуть-чуть но уже надо будет думать.
 - Это числовые типы данных и они не несут никакой дополнительной информации о валюте. Мы можем складывать разные валюты, оперировать не представленными в действительности долями вроде тысячных копеек (хотя тут зависит от того, какие деньги мы моделируем. В наличном мире таких сумм нет, но в безналичном вполне себе)

В целом если нам нужен небольшой скрипт, чтобы посчитать с возможными огрехами какую-то сумму в одной валюте - можно вообще не запариваться (ну или практически) за типы и взять стандартные

```python

def money_sum(money1: int | float | Decimal, money2: int | float | Decimal) -> int | float | Decimal:
	"""Получаем сумму денег. Функция ничего не проверяет, 
	так что вся валидация должна быть снаружи. Молимся, что это одна 
	и та же валюта
	:param int money1: Деньга 1
	:param int money2: Деньга 2
	:return int: Сумма денег
	"""
	return money1 + money2
```

Если приложение будет больше, можно в теории нарваться на совсем какую-нибудь дичь.  Например, у нас баланс пользователя передавался в неименованном кортеже и мы случайно взяли его id вместо суммы. Но это конечно грязные додумки, такого не бывает в приличном обществе.

#### Следующий уровень  - отдельный общий тип

На этом уровне мы моделируем наш тип. Это может быть что-то вроде:
```python
class Money:
    def __init__(self, currency: str, value: Decimal | int | str):
        self.currency = currency

        if isinstance(value, Decimal):
            self.value = value
        elif isinstance(value, (int, str)):
            self.value = Decimal(value)

    def to_dict(self) -> dict[str, str]:
        return {
            "currency": self.currency,
            "value": str(self.value),
        }

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Money):
            return False
        return self.currency == other.currency and self.value == other.value

    def __add__(self, other: Any) -> "Money":
        if other == 0 or other is None:
            return Money(currency=self.currency, value=self.value)

        if isinstance(other, Money):
            if self.currency != other.currency:
                raise TypeError("Cannot add money of different currencies")
            return Money(currency=self.currency, value=self.value + other.value)
        raise TypeError("You can't add Money to another type %s", other)

# ну и там дальше остальные методы допустимых операций
```

Это дает нам возможнсть определить список допустимых операций над типом, ввести дополнительные ограничения (мы не можем складывать разные валюты) и уже  подключать анализатор, использовать этот тип в аннотациях:

```python

def money_sum(money1: Money, money2: Money) -> Money:
	"""Получаем сумму денег. 

	:param Money money1: Деньга 1
	:param Money money2: Деньга 2
	:return Money: Сумма денег
	"""
	return money1 + money2
	
```

Теперь мы застрахованы ещё до запуска приложения от того, что например передадим какой-то случайный `int` в операцию. А в рантайме мы даже защищены от неожиданного сложения разных валют. Хотя и будем неприятно падать.

Но с плюшками приходят и дополнительные проблемы:
- Нужно больше думать на этапе планирования архитектуры. Больше знать о доменной области, ожидаемом поведении. Это увеличивает время разработки.
- Увеличивается количество кода на границах системы. Новые типы нужно спарсить, провалидировать а потом сериализовать и сохранить.
- Могут быть проблемы совместимости со сторонними библиотеками.

#### Больше строгости - тип для каждой валюты

Тут я задался вопросом, а можно ли в целом в питоне просчитать всё на этапе статической проверки типов? 

Получилось как-то так:
```python

class TypedMoney(Generic[LiteralCur]):
    """
    Типизированный вариант Money, где валюта фиксирована (через Literal).
    В потомках нужно определить:
        currency: Literal["USD"] = "USD"
    или другую подходящую строку. Это позволит mypy проверить,
    что нельзя складывать/вычитать разные валюты.

    Примеры конкретных валют:

    class USD(TypedMoney[Literal["USD"]]):
        currency: Literal["USD"] = "USD"

    class RUB(TypedMoney[Literal["RUB"]]):
        currency: Literal["RUB"] = "RUB"

    """

    currency: LiteralCur

    def __init__(self, value: Decimal | int | str):
        self._money = Money(self.currency, value)

    def to_dict(self) -> dict[str, str]:
        return self._money.to_dict()

    def unwrap(self) -> Money:
        return Money(self.currency, self._money.value)

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, TypedMoney):
            return False
        return self._money == other._money

    def __add__(
        self: "TypedMoney[LiteralCur]", other: "TypedMoney[LiteralCur]" | Literal[0]
    ) -> "TypedMoney[LiteralCur]":
        other_value = other.unwrap() if isinstance(other, TypedMoney) else other
        raw_result = self._money.__add__(other_value)
        return self.__class__(raw_result.value)

```
способ дискуссионный, но это в первую очередь синтетический пример, чтобы получить возможность отлавливать сложение на этапе проверки.

После этого мы можем определять классы отдельных валют
```python
class USD(TypedMoney[Literal["USD"]]):
    currency: Literal["USD"] = "USD"

class RUB(TypedMoney[Literal["RUB"]]):
    currency: Literal["RUB"] = "RUB"
```

И уже на них mypy будет предупреждать нас о некорректных операциях ещё на этапе статической проверки:
```python
usd = USD(4)
rub = RUB(5)

total = usd + rub  
# error: Unsupported operand types for + ("USD" and "RUB")  [operator]

def money_sum(money1: TypedMoney[LiteralCur], money2: TypedMoney[LiteralCur]) -> TypedMoney[LiteralCur]:
	"""Получаем сумму денег. 

	:param Money money1: Деньга 1
	:param Money money2: Деньга 2
	:return Money: Сумма денег
	"""
	return money1 + money2

print(money_sum(usd, rub))
# error: Cannot infer type argument 1 of "money_sum"  [misc]
```

Но это приводит нас к ещё большим ограничениям:
 - Теперь надо знать все валюты до запуска приложения, потому что с динамически определенными классами такая штука уже не сработает
 - Нужна дополнительная логика для приведения типов к единому образу


#### Выводы

В целом получаем, что за спасение от потенциальных "глупых" ошибок нужно платить более многословной и строгой системой, требующей качественной проработки на этапе планирования.

На текущий момент я не знаю проектов, которые бы требовали закрытия типами полностью. Рынок очень агрессивная штука и часто чтобы выжить бизнесу может быть выгоднее выкатывать быстро фичи и потом фиксы чем долго планировать и делать "сразу качественно" + более долгое планирование к сожалению не всегда равно более качественный код. Нужно будет подключать бизнес экспертов, желательно понимать в какую сторону будет развиваться функционал дальше. В общем комплексная шутка.  

Но меня радует, что есть инструмент позволяющий увеличить уровень формализованности систем создаваемых на Python.  

код с типами выложил [сюда](https://github.com/Gexeg/money_type)